__xx_cache_1password_fields_to_sqlite() {
    local DB_PATH="${HOME}/.cache/xx/1password.db"
    
    # Create database and table if they don't exist
    sqlite3 "${DB_PATH}" <<EOF
CREATE TABLE IF NOT EXISTS item_fields (
    item_id TEXT NOT NULL,
    field_name TEXT NOT NULL,
    field_type TEXT,
    last_updated INTEGER NOT NULL,
    PRIMARY KEY (item_id, field_name)
);
CREATE INDEX IF NOT EXISTS idx_item_id ON item_fields(item_id);
CREATE INDEX IF NOT EXISTS idx_last_updated ON item_fields(last_updated);
EOF
}

__xx_get_1password_item_fields() {
    source ~/.zshrc.d/xx_functions/__xx_refresh_1password_keychain_entry
    source ~/.zshrc.d/xx_functions/__xx_notify
    
    local ITEM="${1}"
    local FORCE_REFRESH="${2:-false}"
    local SHOW_NOTIFICATIONS="${3:-false}"
    local DB_PATH="${HOME}/.cache/xx/1password.db"
    local CACHE_TTL=86400  # 24 hours in seconds
    
    # Initialize database
    __xx_cache_1password_fields_to_sqlite
    
    # Check if we have cached fields that are still valid
    local NOW=$(date +%s)
    local CACHED_FIELDS=""
    
    if [ "${FORCE_REFRESH}" != "true" ]; then
        CACHED_FIELDS=$(sqlite3 "${DB_PATH}" <<EOF
SELECT field_name 
FROM item_fields 
WHERE item_id = '${ITEM}' 
  AND (${NOW} - last_updated) < ${CACHE_TTL}
ORDER BY 
  CASE field_name 
    WHEN 'password' THEN 0 
    ELSE 1 
  END,
  field_name;
EOF
)
    fi
    
    if [ -n "${CACHED_FIELDS}" ]; then
        echo "${CACHED_FIELDS}"
        return 0
    fi
    
    # Cache miss - show notification if requested
    if [ "${SHOW_NOTIFICATIONS}" = "true" ]; then
        __xx_notify "Fetching fields from 1password item '${ITEM}'" 1000
    fi
    
    # Fetch fresh data from 1Password
    __xx_refresh_1password_keychain_entry > /dev/null 2>&1
    
    local ITEM_JSON=$(op item get "${ITEM}" --format json 2>/dev/null)
    if [ -z "${ITEM_JSON}" ]; then
        return 1
    fi
    
    # Extract fields
    local FIELDS=$(echo "${ITEM_JSON}" | jq -r '.fields[]? | [.label, .type] | @tsv' 2>/dev/null)
    
    if [ -z "${FIELDS}" ]; then
        return 1
    fi
    
    # Clear old cache for this item
    sqlite3 "${DB_PATH}" "DELETE FROM item_fields WHERE item_id = '${ITEM}';"
    
    # Insert new fields into cache
    while IFS=$'\t' read -r field_name field_type; do
        if [ -n "${field_name}" ]; then
            sqlite3 "${DB_PATH}" <<EOF
INSERT OR REPLACE INTO item_fields (item_id, field_name, field_type, last_updated)
VALUES ('${ITEM}', '${field_name}', '${field_type}', ${NOW});
EOF
        fi
    done <<< "${FIELDS}"
    
    # Return sorted fields (password first)
    sqlite3 "${DB_PATH}" <<EOF
SELECT field_name 
FROM item_fields 
WHERE item_id = '${ITEM}'
ORDER BY 
  CASE field_name 
    WHEN 'password' THEN 0 
    ELSE 1 
  END,
  field_name;
EOF
}
