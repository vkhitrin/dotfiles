__xx_cache_1password_fields_to_sqlite() {
    local DB_PATH="${HOME}/.cache/xx/1password.db"
    local DB_DIR="${HOME}/.cache/xx"

    # Ensure cache directory exists
    mkdir -p "${DB_DIR}"

    # Create database and tables if they don't exist
    sqlite3 "${DB_PATH}" <<EOF
CREATE TABLE IF NOT EXISTS item_fields (
    item_id TEXT NOT NULL,
    field_name TEXT NOT NULL,
    field_type TEXT,
    last_updated INTEGER NOT NULL,
    PRIMARY KEY (item_id, field_name)
);

CREATE TABLE IF NOT EXISTS item_cache_metadata (
    item_id TEXT PRIMARY KEY,
    cached_at INTEGER NOT NULL,
    cache_status TEXT NOT NULL CHECK(cache_status IN ('success', 'failure')),
    failure_reason TEXT,
    field_count INTEGER DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_item_id ON item_fields(item_id);
CREATE INDEX IF NOT EXISTS idx_last_updated ON item_fields(last_updated);
CREATE INDEX IF NOT EXISTS idx_cache_metadata_status ON item_cache_metadata(cache_status);
CREATE INDEX IF NOT EXISTS idx_cache_metadata_cached_at ON item_cache_metadata(cached_at);
EOF
}

__xx_get_1password_item_fields() {
    source ~/.zshrc.d/xx_functions/__xx_refresh_1password_keychain_entry
    source ~/.zshrc.d/xx_functions/__xx_notify

    local ITEM="${1}"
    local FORCE_REFRESH="${2:-false}"
    local SHOW_NOTIFICATIONS="${3:-false}"
    local DB_PATH="${HOME}/.cache/xx/1password.db"
    local CACHE_TTL=86400  # 24 hours in seconds

    # Initialize database
    __xx_cache_1password_fields_to_sqlite

    # Check if we have cached fields that are still valid
    local NOW=$(date +%s)
    local CACHED_FIELDS=""

    if [ "${FORCE_REFRESH}" != "true" ]; then
        # Check metadata first to see if item is cached and not expired
        local CACHE_STATUS=$(sqlite3 "${DB_PATH}" <<EOF
SELECT cache_status
FROM item_cache_metadata
WHERE item_id = '${ITEM}'
  AND (${NOW} - cached_at) < ${CACHE_TTL};
EOF
)

        if [ "${CACHE_STATUS}" = "success" ]; then
            CACHED_FIELDS=$(sqlite3 "${DB_PATH}" <<EOF
SELECT field_name
FROM item_fields
WHERE item_id = '${ITEM}'
ORDER BY
  CASE field_name
    WHEN 'password' THEN 0
    ELSE 1
  END,
  field_name;
EOF
)
        fi
    fi

    if [ -n "${CACHED_FIELDS}" ]; then
        echo "${CACHED_FIELDS}"
        return 0
    fi

    # Cache miss - show notification if requested
    if [ "${SHOW_NOTIFICATIONS}" = "true" ]; then
        __xx_notify "Fetching fields from 1password item '${ITEM}'" 1000
    fi

    # Fetch fresh data from 1Password
    __xx_refresh_1password_keychain_entry > /dev/null 2>&1

    # Get item JSON - try to extract fields with error handling for control characters
    local FETCH_OUTPUT=$(op item get "${ITEM}" --format json 2>&1)
    local FETCH_EXIT_CODE=$?

    if [ ${FETCH_EXIT_CODE} -ne 0 ]; then
        # Record failure in metadata
        local FAILURE_REASON=$(echo "${FETCH_OUTPUT}" | head -1 | sed "s/'/''/g")
        sqlite3 "${DB_PATH}" <<EOF
INSERT OR REPLACE INTO item_cache_metadata (item_id, cached_at, cache_status, failure_reason, field_count)
VALUES ('${ITEM}', ${NOW}, 'failure', '${FAILURE_REASON}', 0);
EOF
        return 1
    fi

    local FIELDS=$(echo "${FETCH_OUTPUT}" | \
        jq -r '.fields[]? | select(.label != null) | [.label, .type] | @tsv' 2>&1 | \
        grep -v "jq: parse error")

    if [ -z "${FIELDS}" ]; then
        # No fields found - could be secure note or document
        sqlite3 "${DB_PATH}" <<EOF
INSERT OR REPLACE INTO item_cache_metadata (item_id, cached_at, cache_status, failure_reason, field_count)
VALUES ('${ITEM}', ${NOW}, 'failure', 'No fields found', 0);
EOF
        return 1
    fi

    # Clear old cache for this item
    sqlite3 "${DB_PATH}" <<EOF
DELETE FROM item_fields WHERE item_id = '${ITEM}';
DELETE FROM item_cache_metadata WHERE item_id = '${ITEM}';
EOF

    # Count fields
    local FIELD_COUNT=$(echo "${FIELDS}" | wc -l | tr -d ' ')

    # Insert new fields into cache
    while IFS=$'\t' read -r FIELD_NAME FIELD_TYPE; do
        if [ -n "${FIELD_NAME}" ]; then
            # Escape single quotes for SQL
            local ESCAPED_FIELD_NAME=$(echo "${FIELD_NAME}" | sed "s/'/''/g")
            local ESCAPED_FIELD_TYPE=$(echo "${FIELD_TYPE}" | sed "s/'/''/g")
            sqlite3 "${DB_PATH}" <<EOF
INSERT OR REPLACE INTO item_fields (item_id, field_name, field_type, last_updated)
VALUES ('${ITEM}', '${ESCAPED_FIELD_NAME}', '${ESCAPED_FIELD_TYPE}', ${NOW});
EOF
        fi
    done <<< "${FIELDS}"

    # Insert success metadata
    sqlite3 "${DB_PATH}" <<EOF
INSERT OR REPLACE INTO item_cache_metadata (item_id, cached_at, cache_status, failure_reason, field_count)
VALUES ('${ITEM}', ${NOW}, 'success', NULL, ${FIELD_COUNT});
EOF

    # Return sorted fields (password first)
    sqlite3 "${DB_PATH}" <<EOF
SELECT field_name
FROM item_fields
WHERE item_id = '${ITEM}'
ORDER BY
  CASE field_name
    WHEN 'password' THEN 0
    ELSE 1
  END,
  field_name;
EOF
}
